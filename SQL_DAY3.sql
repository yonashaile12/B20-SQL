-- SINGLE ROW FUNCTION 
-- WILL AFFECT EACH AND EVERY ROW AND RETURN SAME NUMBER OF ROWS 
-- LENGTH , UPPER , LOWER , SUBSTR 

SELECT UPPER(FIRST_NAME) , LOWER(LAST_NAME) 
        , SUBSTR(FIRST_NAME , 1,1) || SUBSTR(LAST_NAME , 1,1)  AS INITIALS
FROM EMPLOYEES ; 

-- PARTIAL STRING CONDIITON USING LIKE % 
-- FIND EMPLOYEES THAT CONTAINS MI IN THEIR NAME (COULD BE FIRST NAME OR LAST NAME) , 
-- CASE INSENSITIVE 

SELECT FIRST_NAME , LAST_NAME
FROM EMPLOYEES 
WHERE LOWER(FIRST_NAME) LIKE '%mi%' 
  OR  UPPER (LAST_NAME) LIKE '%MI%'  
; 

----123456789
--  17-JUN-03

-- SUBSTR (VALUE , STARTING INDEX , CHARATER COUNT YOU WANT TO GET!!!)
SELECT HIRE_DATE , SUBSTR(HIRE_DATE, 4, 3) AS HIRE_MONTH
FROM EMPLOYEES ; 

-- BY EXTENDING ABOVE QUERY , FIND OUT EVERYONE WHO IS HIRED IN JAN 
SELECT FIRST_NAME , HIRE_DATE 
FROM EMPLOYEES 
WHERE SUBSTR(HIRE_DATE, 4, 3) = 'JAN' ; 


-- MATH OPERATION IN SQL  (LETS CLEAR THIS OUT BEFORE WE TALK ABOUT MULTI-ROW FUNCTION)
-- MATH OPERATION IS SAME AS YOUR JAVA 
-- IF YOU HAVE FRACTIONAL NUMBER YOU CAN USE ROUND FUNCTION TO ROUND UP THE NUMBER 

SELECT SALARY AS MONTHLY_SAL , 
       SALARY + 1000 AS AFTER_RAISE,   
       SALARY / 4  AS WEEKLY_SALARY,   
       --SALARY /30  AS DAILY_SALARY , 
       ROUND ( SALARY/30 , 2) AS ROUNDED_DAILY
       
FROM EMPLOYEES ; 



------  lets count how many ppl are in employee table 
SELECT * FROM EMPLOYEES ; 

SELECT COUNT(*) FROM EMPLOYEES ; 
SELECT COUNT(FIRST_NAME) FROM EMPLOYEES ; 

-- TASK COUNT THE ROW COUNT OF EACH AND EVERY TABLE 

SELECT COUNT(*) AS DEP_COUNT FROM DEPARTMENTS ; 

SELECT COUNT(*) AS COUNTRY_COUNT FROM COUNTRIES ; 

SELECT COUNT(*) AS JOB_COUNT FROM JOBS ; 

SELECT COUNT(*) AS LOCATION_COUNT FROM LOCATIONS ; 

SELECT COUNT(*) AS REGIONS_COUNT FROM REGIONS ; 

SELECT COUNT(*) AS HISTORY_COUNT FROM JOB_HISTORY ; 

--  FIND OUT WHO MAKE THE MOST MONEY IN EMPLOYEES TABLE 

SELECT MAX(SALARY) FROM EMPLOYEES;

--  FIND OUT WHO MAKE THE LEAST MONEY IN EMPLOYEES TABLE 

SELECT MIN(SALARY) FROM EMPLOYEES  ; 

--  FIND OUT THE MONTHLY TOTAL BUDGET FOR EMPLOYEES SALARY ( GET THE SUM OF ALL SALARY )

SELECT SUM (SALARY) FROM EMPLOYEES ; 

--  FIND OUT THE AVERAGE SALARY OF ALL EMPLOYEES 

SELECT   AVG(SALARY) , 
         ROUND( AVG(SALARY) ) AS AVERAGE_SALARY , 
         ROUND( AVG(SALARY) , 2 ) AS AVERAGE_SAL_2DIGIT
FROM EMPLOYEES ; 



-- FIND OUT ALL ABOVE IN ONE SHOT 
SELECT  COUNT(*) AS EMPLOYEE_COUNT , 
        MAX(SALARY) AS MAXIMUN_SALARY , 
        MIN(SALARY) AS MINIMUN_SALARY , 
        SUM(SALARY) AS SALARY_TOTAL , 
        ROUND( AVG(SALARY) , 2 ) AS AVERAGE_SAL_2DIGIT

FROM EMPLOYEES ; 



-- FIND OUT HOW MANY EMPLOYEE IN EACH DEPARTMENTS 
SELECT DEPARTMENT_ID  , COUNT(*) AS DEP_EMP_CNT
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID ; 

-- FIND OUT HOW MANY EMPLOYEE IN EACH JOB_ID CATEGORY 
SELECT JOB_ID , COUNT(*) AS JOB_ID_EMP_CNT
FROM EMPLOYEES 
GROUP BY JOB_ID ; 


-- THIS IS A BAD QUERY !!! IF YOU ADD ANY EXTRA COLUMN 
-- YOU MUST USE GROUP BY TO SPECIFY THE GROUPING CRITERIA!!!!
-- ORA-00937: not a single-group group function
SELECT JOB_ID , COUNT(*) AS JOB_ID_EMP_CNT
FROM EMPLOYEES ; 

-- THIS DOES NOT MAKE SENSE!!!!!!
-- GROUP BY ONLY CAN BE USED WITH AGGREGATE FUNCTIONS !!!!!!!
-- ORA-00979: not a GROUP BY expression
SELECT FIRST_NAME 
FROM EMPLOYEES 
GROUP BY JOB_ID ; 



-- FIND OUT MAX SALARY IN EACH DEPARTMENT_ID  
SELECT MAX(SALARY) , DEPARTMENT_ID
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID ; 

-- FIND OUT MIN SALARY IN EACH DEPARTMENT_ID 
SELECT MIN(SALARY) , DEPARTMENT_ID
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID ; 


-- FIND OUT SUM OF SALARY IN EACH DEPARTMENT_ID 
SELECT SUM(SALARY) , DEPARTMENT_ID
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID ; 

-- FIND OUT AVG OF SALARY IN EACH DEPARTMENT_ID 
SELECT  ROUND ( AVG(SALARY) ) , DEPARTMENT_ID
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID ; 

-- WE CAN COMBINE ALL ABOVE BECAUSE ALL OF THEM ARE GROUPING THE RESULT BY DEPARTMENT_ID


-- FIND OUT ALL ABOVE IN ONE SHOT 
SELECT  DEPARTMENT_ID , 
        COUNT(*) AS EMPLOYEE_COUNT , 
        MAX(SALARY) AS MAXIMUN_SALARY , 
        MIN(SALARY) AS MINIMUN_SALARY , 
        SUM(SALARY) AS SALARY_TOTAL , 
        ROUND( AVG(SALARY) , 2 ) AS AVERAGE_SAL_2DIGIT

FROM EMPLOYEES 
    GROUP BY DEPARTMENT_ID
; 



-- FIND OUT HOW MANY EMPLOYEE IN EACH DEPARTMENTS 
SELECT DEPARTMENT_ID  , COUNT(*) AS DEP_EMP_CNT
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID ; 

-- FIND OUT HOW MANY EMPLOYEE IN EACH DEPARTMENTS 
--- RESTRICT THE RESULT TO DISPLAY ONLY THOSE DEPARTMENT WITH EMP COUNT MORE THAN 10 

--- IF YOU HAVE MORE CONDITIONS AFTER GROUP BY 
--- YOU CAN USE HAVING CLAUSE  (WHERE DOES NOT WORK HERE !!!!!!)

SELECT DEPARTMENT_ID  , COUNT(*) AS DEP_EMP_CNT
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID 
HAVING  COUNT(*) > 10   -- Aggregate function can be used after HAVING to restrict reuslt even more 
                        -- WHERE DOES NOT WORK HERE !!!!!!!
; 

-- FIND OUT MAX SALARY IN EACH DEPARTMENT_ID  
SELECT MAX(SALARY) , DEPARTMENT_ID
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID ; 

--- BY EXTENDING ABOVE QUERY , FIND FIND OUT DEPARTMENT WITH MAX SALARY LESS THAN 10000
SELECT MAX(SALARY) , DEPARTMENT_ID
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID 
HAVING MAX(SALARY) <10000 
; 
-- ONLY PLACE HAVING CLAUSE CAN SHOW UP IS RIGHT AFTER THE GROUP BY !!!!!!!

-- FROM LOCAITONS TABLE , FIND OUT HOW MANY LOCATION IN EACH COUNTRY(_ID)
SELECT COUNTRY_ID , COUNT(*)
FROM LOCATIONS 
GROUP BY COUNTRY_ID ;


--- HOW DO I SORT IN SQL 
--- ORDER BY CLAUSE 
-- FOR EXAMPLE : ORDER BY COLUMN NAME OR COLUMN INDEX 

SELECT * FROM EMPLOYEES 
ORDER BY FIRST_NAME ASC  -- DEFAULT ORDER IS ALWAYS ASCENDING ORDER , LOW TO HIGH 
; 


SELECT * FROM EMPLOYEES 
ORDER BY FIRST_NAME DESC  -- MUST BE SET EXPLICITLY , HIGH TO LOW 
; 


-- ORDER THE RESULT BY THE SALARY ASC 
SELECT * FROM EMPLOYEES 
ORDER BY SALARY ASC  ; 

-- ORDER THE RESULT BY THE SALARY DESC 
SELECT * FROM EMPLOYEES 
ORDER BY SALARY DESC  ; 



-- FIND OUT MAX SALARY IN EACH DEPARTMENT_ID  AND ORDER BY DEPARTMENT_ID
SELECT MAX(SALARY) , DEPARTMENT_ID
FROM EMPLOYEES 
GROUP BY DEPARTMENT_ID 
ORDER BY DEPARTMENT_ID
; 




